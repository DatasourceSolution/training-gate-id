\input{../config.tex}

\title{Dynamic Programming}
\author{Tim Olimpiade Komputer Indonesia}
\date{}

\usepackage{qtree}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Pendahuluan}
Melalui dokumen ini, kalian akan:
\begin{itemize}
  \item Memahami konsep \foreignTerm{Dynamic Programming} (DP).
  \item Menyelesaikan beberapa contoh persoalan DP sederhana.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi}
\begin{itemize}
  \item Diberikan $M$ jenis koin, masing-masing jenis bernilai $a_1, a_2, ..., a_M$ rupiah.
  \item Asumsikan terdapat tak hingga koin untuk setiap nominal koin yang ada. 
  \item Tentukan berapa banyaknya minimal koin untuk membayar sebesar $N$ rupiah!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Mari kita coba menyelesaikan masalah ini secara \fGreedy.
  \item Salah satu algoritma \fGreedy yang mungkin adalah dengan menggunakan koin terbesar yang $\leq$ sisa uang yang harus dibayar.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Misalkan kita memiliki nominal koin 1 rupiah, 6 rupiah, dan 10 rupiah dan ingin membayar 12 rupiah.
  \item Dengan algoritma sebelumnya, kita akan menggunakan koin 10 rupiah terlebih dahulu. 
  \item Karena tersisa 2 rupiah, berikutnya kita akan menggunakan 2 koin 1 rupiah, sehingga totalnya kita menggunakan 3 koin.
  \item Namun, ada solusi lebih baik: 2 koin 6 rupiah.
  \item Algoritma \fGreedy ini tidak memberikan solusi terbaik.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Observasi}
\begin{itemize}
  \item Untuk membayar $N$ rupiah, kita dapat memilih salah satu koin terlebih dahulu.
  \item Jika nilai koin itu adalah $a_k$, maka sisa uang uang perlu kita bayar adalah $N-a_k$.
  \item Dalam kasus ini, terdapat $M$ pilihan koin untuk $a_k$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Observasi}
\begin{itemize}
  \item Perhatikan bahwa penukaran $N - a_k$ merupakan suatu sub-persoalan yang serupa dengan persoalan awalnya.
  \item Artinya, cara yang sama untuk menyelesaikan sub-persoalan dapat digunakan.
  \item Kita akan menggunakan strategi penyelesaian secara rekursif.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{itemize}
  \item Definisikan sebuah fungsi $f(x)$ sebagai banyaknya koin minimum yang dibutuhkan untuk membayar $x$ rupiah.
  \item Kita dapat mencoba-coba koin yang ingin kita gunakan.
  \item Jika suatu koin $a_k$ digunakan, maka kita membutuhkan $f(x-a_k)$ koin ditambah satu koin $a_k$.
  \item Atau dapat ditulis $f(x) = f(x-a_k) + 1$
  \item Pencarian nilai $f(x-a_k)$ dilakukan secara rekursif, kita kembali mencoba-coba koin yang ingin digunakan.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{itemize}
  \item Dari semua kemungkinan $a_k$, mana pilihan yang terbaik?
  \item Pilihan yang terbaik akan memberikan nilai $f(x - a_k) + 1$ sekecil mungkin.
  \item Jadi kita cukup mencoba semua kemungkinan $a_k$, dan ambil yang hasil $f(x - a_k) + 1$ terkecil.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{itemize}
  \item Jika $f(x)$ dihitung secara rekursif, apa yang menjadi \fbasecase?
  \item Kasus terkecilnya adalah $f(0)$, yang artinya kita hendak membayar 0 rupiah.
  \item Membayar 0 rupiah tidak membutuhkan satu pun koin, sehinga $f(0) = 0$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{codebox}
\Procname{$\proc{f}(x)$}
\li \If $(x \isequal 0)$ \Then
\li   \Return $0$
\li \Else
\li   $best \gets \infty$
\li   \For $k \gets 1$ \To $M$ \Do
\li     \If $(a_k \leq x)$ \Then
\li       $best \gets \min(best, \proc{f}(x - a_k) + 1)$
        \End
      \End
\li   \Return $best$
    \End
\end{codebox}

Jawaban akhirnya ada pada $f(N)$.
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{itemize}
  \item Secara matematis, dituliskan:
   \[f(x) = \left\{\begin{array}{lr}
        0, & n = 0\\
        \min_{1 \leq k \leq M, a_k \leq x} {f(x - a_k) + 1}, & n > 0\\
        \end{array}\right. \]
 \end{itemize}
\end{frame}

\begin{frame} [fragile]
\frametitle{Solusi rekursif (lanj.)}
Mari kita lihat pohon rekursi yang dihasilkan oleh fungsi $f$. 

Berikut untuk $f(12)$ dengan nominal koin 1, 6, dan 10 rupiah.

\begin{center}
\scalebox{0.9}{
\Tree [.$f(12)$
  [.$f(2)$
    [.$f(1)$
      [.$f(0)$ ]
    ]
  ]
  [.$f(6)$
    [.$f(0)$ ]
    [.$f(5)$
      [.$f(4)$
        [.$...$
        ]
      ]
    ]
  ]
  [.$f(11)$
    [.$f(1)$
      [.$f(0)$ ]
    ]
    [.$f(5)$
      [.$f(4)$
        [.$...$          
        ]
      ]
    ]
    [.$f(10)$ 
      [.$f(0)$ 
        [.$...$ ]      
      ]
      [.$f(4)$ 
        [.$...$ ]      
      ]
      [.$f(9)$ 
        [.$...$ ]      
      ]
    ]
  ]
]
}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif (lanj.)}
\begin{itemize}
  \item Jika diperhatikan pada pohon rekursi, terdapat $O(M)$ cabang untuk setiap pemanggilan $f$.
  \item Untuk menghitung nilai $f(N)$, kita akan memiliki pohon rekursi yang kira-kira sedalam $O(N)$.
  \item Berarti kira-kira dilakukan $O(N^M)$ pemanggilan fungsi.
  \item Karena itu, solusi ini membutuhkan $O(N^M)$ operasi, yang mana banyaknya operasi ini eksponensial terhadap $N$ atau $M$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif (lanj.)}
\begin{itemize}
  \item Biasanya solusi eksponensial berjalan sangat lambat.
  \item Kita tidak ingin memiliki solusi eksponensial pada pemrograman kompetitif, kecuali pada soal-soal tertentu dimana tidak terdapat solusi polinomial. 
  \item Karena itu, kita harus melakukan sebuah optimisasi.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Optimisasi}
Jika diperhatikan, ternyata banyak $f(x)$ yang dihitung berkali-kali. Sebagai contoh, $f(5)$ dan $f(4)$.
\begin{center}
\scalebox{0.8}{
\Tree [.$f(12)$
  [.$f(2)$
    [.$f(1)$
      [.$f(0)$ ]
    ]
  ]
  [.$f(6)$
    [.$f(0)$ ]
    [.$f(5)$
      [.$f(4)$
        [.$...$
        ]
      ]
    ]
  ]
  [.$f(11)$
    [.$f(1)$
      [.$f(0)$ ]
    ]
    [.$f(5)$
      [.$f(4)$
        [.$...$          
        ]
      ]
    ]
    [.$f(10)$ 
      [.$f(0)$ 
        [.$...$ ]      
      ]
      [.$f(4)$ 
        [.$...$ ]      
      ]
      [.$f(9)$ 
        [.$...$ ]      
      ]
    ]
  ]
]
}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Optimisasi}
\begin{itemize}
  \item Perhatikan bahwa hanya ada $N + 1$ kemungkinan $x$ untuk $f(x)$, yaitu $0$ sampai $N$.
  
  \item Kita dapat melakukan \newTerm{memoisasi}, yaitu mencatat hasil perhitungan $f(x)$ setelah menghitungnya.
  \item Jika suatu ketika kita kembali memerlukan nilai $f(x)$, kita tidak perlu menghitungnya kembali.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Solusi rekursif}
\begin{codebox}
\Procname{$\proc{f}(x)$}
\li \If $(x \isequal 0)$ \Then
\li   \Return $0$
\li \ElseIf $hasComputed[x]$ \Then
\li   \Comment Langsung kembalikan
\li   \Return $memo[x]$ 
\li \Else
\li   $best \gets \infty$
\li   \For $k \gets 1$ \To $M$ \Do
\li     \If $(a_k \leq x)$ \Then
\li       $best \gets \min(best, \proc{f}(x - a_k) + 1)$
        \End
      \End
\li   \Comment Catat hasilnya      
\li   $hasComputed[x] \gets true$
\li   $memo[x] \gets best$
\li   \Return $best$
    \End
\end{codebox}
\end{frame}

\begin{frame}
\frametitle{Optimisasi}
\begin{itemize}
  \item Untuk menghitung suatu nilai $f(x)$, kita membutuhkan $O(M)$ iterasi.
  \item Sehingga untuk menghitung nilai $f(x)$ untuk seluruh $x$, kita membutuhkan $O(NM)$ operasi.
  \item Banyaknya operasi ini polinomial terhadap $N$ dan $M$, dan \\ \emp{jauh lebih cepat} daripada solusi rekursif sebelumnya.
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Dynamic Programming}
\begin{itemize}
  \item Merupakan metode penyelesaian persoalan yang melibatkan pengambilan keputusan dengan memanfaatkan informasi dari penyelesaian sub-persoalan yang sama namun lebih kecil
  \item Solusi sub-persoalan tersebut hanya dihitung satu kali dan disimpan di memori.
  \item Jika sebuah persoalan adalah masalah optimisasi, maka biasanya kita mencoba semua kemungkinan solusi sub-problem yang dihasilkan, dan  mengambil yang hasilnya paling optimal. 
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Dynamic Programming}
Terdapat dua cara mengimplementasikan DP
\begin{itemize}
  \item \newTerm{\fTopdown}: diimplementasikan secara rekursif sambil mencatat nilai yang sudah ditemukan (memoisasi).
  \item \newTerm{\fBottomup}: diimplementasikan secara iteratif dengan menghitung mulai dari kasus yang kecil ke besar.
  \newline
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Top Down}
\begin{itemize}
  \item Cara yang sebelumnya kita gunakan adalah \ftopdown.
  \item Kata memoisasi berasal dari "memo", yang artinya catatan.
  \item Pada \ftopdown, penyelesaian masalah dimulai dari kasus yang besar.
  \item Untuk menyelesaikan kasus yang besar, dibutuhkan solusi dari kasus yang lebih kecil.
  \item Karena solusi kasus yang lebih kecil belum ada, maka kita akan mencarinya terlebih dahulu, lalu mencatat hasilnya.
  \item Hal ini dilakukan secara rekursif.
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Bottom Up}
\begin{itemize}
  \item Pada \fbottomup, penyelesaian masalah dimulai dari kasus yang kecil.
  \item Ketika merumuskan formula rekursif, kita mengetahui jawaban kasus yang paling kecil, yaitu \fbasecase.
  \item Informasi ini digunakan untuk menyelesaikan kasus yang \\ lebih besar.
  \item Biasanya dianalogikan dengan pengisian "tabel DP".
  \item Hal ini dilakukan secara iteratif.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Cara lain}
Secara bottom up, kita hitung semua nilai $f(x)$ untuk semua nilai $x$ dari $0$ sampai $N$ secara menaik.
\begin{codebox}
\Procname{$\proc{solve}(N)$}
\li $f[0] \gets 0$
\li \For $x \gets 1$ \To $N$ \Do
\li   $best \gets \infty$
\li   \For $k \gets 1$ \To $M$ \Do
\li     \If $(a_k \leq x)$ \Then
\li       $best \gets \min(best, f[x - a_k] + 1)$
        \End
      \End
\li   $f[x] \gets best$
    \End
\li \Return $f[N]$
\end{codebox}
\end{frame}

\begin{frame}
\frametitle{Top Down dan Bottom Up}
TODO: simulasi isi tabel bottom up
\end{frame}

\begin{frame}
\frametitle{Top Down dan Bottom Up}
Top Down
\begin{itemize}
  \item Sebuah transformasi natural dari formula rekursif, biasanya mudah diimplementasikan.
  \item Urutan pengisian tabel tidak penting.
  \item Hanya menghitung nilai dari fungsi jika hanya diperlukan.
  \item Ketika seluruh tabel memo pada akhirnya terisi, bisa saja lebih lambat karena adanya 
  \foverhead pemanggilan fungsi.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Top Down dan Bottom Up}
Bottom Up
\begin{itemize}
  \item Tidak mengalami perlambatan dari \foverhead pemanggilan fungsi.
  \item Memungkinkan penggunaan teknik DP lanjutan seperti \foreignTerm{flying table}, kombinasi dengan struktur data \foreignTerm{tree}, dsb.
  \item Harus memikirkan urutan pengisian nilai tabel.
  \item Semua tabel harus diisi nilainya walaupun tidak dibutuhkan akhirnya.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Top Down dan Bottom Up}
\begin{itemize}
  \item Beberapa orang lebih alami untuk menggunakan \ftopdown, sementara sisanya lebih terbiasa dengan \fbottomup.
  \item Bergantung dari cara berpikir Anda, salah satunya mungkin lebih mudah Anda pelajari.
  \item Untuk orang yang telah berpengalaman, penggunaan \fbottomup dan \ftopdown dapat disesuaikan dengan soal yang dihadapi.
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Contoh Soal 1: Knapsack}
\begin{itemize}
  \item Diberikan $N$ buah barang. Barang ke-$i$ memiliki harga $v_i$ rupiah dan memiliki berat $w_i$ gram. Kita memiliki tas yang berkapasitas $G$ gram. 
  \item Kita ingin memasukan beberapa barang kedalam tas sedemikian sehingga jumlah berat dari barang-barang yang kita masukan tidak lebih dari kapasitas tas dan jumlah harga dari barang-barang yang kita masukan sebanyak mungkin.
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Contoh Soal 1: Knapsack (Solusi)}
\begin{itemize}
  \item Marilah kita definisikan sebuah fungsi $g(x,y)$ adalah jumlah harga maksimum yang mungkin diperoleh, jika kita hanya mempunyai barang ke-$1$ sampai ke-$x$ dan kapasitas tas kita adalah $y$ gram.
  \item Untuk menghitung fungsi $g(x,y)$ kita bisa mencoba-coba apakah kita akan memasukan barang ke-$x$ ke tas.
  \begin{itemize}
  \item Jika kita memasukan barang ke-$x$ ke tas, maka kita akan menyisakan barang ke-$1$ sampai ke-$x-1$ dan sisa kapasitas tas adalah $y-w_x$. Kita dapat menghitung jumlah harga maksimum pada kasus ini pada $g(x-1,y-w_x)$ ditambah dengan harga yang kita peroleh pada barang ke-$x$. Kasus ini hanya boleh dipertimbangkan jika $y \geq w_x$.
  \item Jika kita tidak memasukan barang ke-$x$ ke tas, maka kita akan menyisakan barang ke-$1$ sampai ke-$x-1$ dan sisa kapasitas tas masih tetap $y$, sehingga jumlah harga maksimumnya adalah $g(x-1,y)$ tanpa tambahan apapun, karena kita tidak mengambil barang ke-$x$.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Contoh Soal 1: Knapsack (Solusi (lanj.))}
\begin{itemize}
  \item Jika $x=0$, maka $g(x,y)$ berarti tidak ada sisa barang yang tersedia. Ini berarti $g(x,y) = 0$.
  \item Sehingga, $g(x,y)$ dapat dirumuskan sebagai berikut
  % Rumus ini mungkin saja panjang dan mungkin saja tidak dapat dicakup pada slide
  \begin{small}
  \[g(x,y) = \left\{\begin{array}{lr}
        0, & x = 0\\
        g(x-1,y), & x > 0 \wedge y < w_x\\
        \max(g(x-1,y-w_x)+v_x,g(x-1,y)), & x > 0 \wedge y \geq w_x\\
        \end{array}\right\}\]
  \end{small}
  \item Terdapat $O(N)$ nilai berbeda untuk nilai $x$ dan $O(G)$ nilai berbeda untuk nilai $y$ pada $g(x,y)$. Dibutuhkan $O(1)$ iterasi untuk menghitung $g(x,y)$. Sehingga untuk menghitung seluruh nilai $g(x,y)$ untuk seluruh $x$ dan $y$ dibutuhkan waktu $O(NG)$.
\end{itemize}
\end{frame}

\begin{frame} [fragile]
\frametitle{Contoh Soal 1: Knapsack (Pseudocode)}
  Berikut adalah contoh implementasi menggunakan rekursi diatas dan memoisasi.
  \begin{lstlisting}
    function g(x,y)
      if (x == 0)
        return 0
      if (sudahDihitung[x][y])
        return hasilHitungan[x][y]
      hasil = g(x-1,y)
      if (y >= w[x]) hasil = max(hasil, g(x-1,y-w[x]) + v[x])
      sudahDihitung[x][y] = true
      hasilHitungan[x][y] = hasil
      return hasil
  \end{lstlisting}
  Hasil jawaban terdapat pada 
  \begin{lstlisting}
    g(N, G)
  \end{lstlisting}
  karena pada awalnya kita memiliki seluruh barang dari barang ke-$1$ sampai barang ke-$N$ dan kapasitas tas adalah $G$ gram.
\end{frame}

\begin{frame} [fragile]
\frametitle{Contoh Soal 1: Knapsack (Pseudocode (lanj.))}
  Berikut adalah contoh implementasi menggunakan solusi \foreignTerm{bottom up}.
  \begin{lstlisting}
    for j in [0, G]
      g[0][j] = 0
    for i in [1,N]
      for j in [0,G]
        g[i][j] = g[i-1][j]
        if (j >= w[i])
          g[i][j] = max(g[i][j], g[i-1][j-w[x]] + v[x])
  \end{lstlisting}
  Hasil jawaban terdapat pada
  \begin{lstlisting}
    g[N][G]
  \end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Contoh Soal 2: Memotong Kayu}
\begin{itemize}
  \item Kita harus memotong-motong sebuah batang kayu dengan panjang $M$ meter pada $N$ titik menjadi $N+1$ bagian. Titik ke-$i$ berada di $L_i$ meter dari sebuah ujung.
  \item Untuk memotong sebatang kayu menjadi dua, kita memerlukan usaha sebanyak panjang kayu yang sedang kita potong.
  \item Sebagai contoh, terdapat sebuah kayu dengan panjang 10 meter dan terdapat 3 titik potongan pada 2 meter, 4 meter, dan 7 meter dari sebuah ujung. Kita bisa memotong pada titik 2, titik 4, lalu titik 7 dan memerlukan usaha 10 + 8 + 6 = 24. Cara lain adalah memotong pada titik 4, titik 2, lalu titik 7 dan memerlukan usaha 10 + 4 + 6 = 20.
  \item Kita harus mencari urutan pemotongan sedemikian sehingga total usaha yang dibutuhkan minimum.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Contoh Soal 2: Memotong Kayu (Solusi)}
\begin{itemize}
  \item Marilah kita definisikan sebuah fungsi $g(x,y)$ adalah jumlah usaha minimum yang mungkin diperoleh, jika kita hanya perlu memotong potongan-potongan dari potongan ke-$x$ sampai ke-$y$.
  \item Untuk menghitung fungsi $g(x,y)$ kita bisa mencoba-coba potongan manakah yang kita potong pertama kali.
  \item Jika kita memotong potongan ke-$k$ $(x \leq k \leq y)$, maka kita akan mendapatkan dua potongan. Total usaha minimum dari potongan pertama adalah $g(x,k-1)$ dan total usaha minimum dari potongan kedua adalah $g(k+1,y)$ dan usaha yang dibutuhkan dari potongan pertama adalah panjang potongan saat ini, yaitu $L_{y+1} - L_{x-1}$, dengan $L_0 = 0$ dan $L_{N+1} = M$.
\end{itemize}
\end{frame}

\begin{frame} 
\frametitle{Contoh Soal 2: Memotong Kayu (Solusi (lanj.))}
\begin{itemize}
  \item Jika $x>y$, maka $g(x,y)$ berarti tidak ada potongan kayu yang tersisa. Ini berarti $g(x,y) = 0$.
  \item Sehingga, $g(x,y)$ dapat dirumuskan sebagai berikut
  % Rumus ini mungkin saja panjang dan mungkin saja tidak dapat dicakup pada slide
  \begin{small}
  \[g(x,y) = \left\{\begin{array}{lr}
        0, & x>y\\
        \min_{x \leq i \leq y} g(x,i-1) + g(i+1,y) + (L_{y+1} - L_{x-1}) & x \leq y \\
        \end{array}\right\}\]
  \end{small}
  \item Terdapat $O(N)$ nilai berbeda untuk nilai $x$ dan $O(N)$ nilai berbeda untuk nilai $y$ pada $g(x,y)$. Dibutuhkan $O(N)$ iterasi untuk menghitung $g(x,y)$. Sehingga untuk menghitung seluruh nilai $g(x,y)$ untuk seluruh $x$ dan $y$ dibutuhkan waktu $O(N^3)$.
\end{itemize}
\end{frame}

\begin{frame} [fragile]
\frametitle{Contoh Soal 2: Memotong Kayu (Pseudocode)}
  Berikut adalah contoh implementasi menggunakan rekursi diatas dan memoisasi.
  % Kode ini mungkin saja panjang dan mungkin saja tidak dapat dicakup pada slide, sehingga beberapa baris (seperti if(x > y) return 0) harus dibuat satu line
  \begin{lstlisting}
    function g(x,y)
      if (x > y) return 0
      if (sudahDihitung[x][y]) return hasilHitungan[x][y]
      hasil = INFINITY
      for i in range[x,y]
        hasil = min(hasil, g(x,i-1) + g(i+1,y))
      hasil = hasil + L[y+1] - L[x-1]
      sudahDihitung[x][y] = true
      hasilHitungan[x][y] = hasil
      return hasil
  \end{lstlisting}
  Hasil jawaban terdapat pada 
  \begin{lstlisting}
    g(1, N)
  \end{lstlisting}
  karena pada awalnya kita harus memotong seluruh titik potongan dari potongan ke-$1$ sampai potongan ke-$N$.
\end{frame}

\begin{frame} [fragile]
\frametitle{Contoh Soal 2: Memotong Kayu (Pseudocode (lanj.))}
  Berikut adalah contoh implementasi menggunakan solusi \foreignTerm{bottom up}. Perhatikan urutan pengisian tabel $g$
  \begin{lstlisting}
    L[0] = 0, L[N+1] = M
    for i in [0,N+1]
      for j in [0,N+1]
        if (i > j) g[i][j] = 0
    for dif in [0,N]
      for i in [1, N - dif]
        j = i + dif
        g[i][j] = INFINITY
	for k in [i,j]
	  g[i][j] = min(g[i][j], g[i][k-1] + g[k+1][j])
	g[i][j] += L[j+1] - L[i-1]
  \end{lstlisting}
  Hasil jawaban terdapat pada
  \begin{lstlisting}
    g[1][N]
  \end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Penutup}
\begin{itemize}
  \item DP merupakan topik yang cukup luas untuk dibicarakan.
  \item Terdapat dua versi DP, yaitu \foreignTerm{bottom up} dan \foreignTerm{top down}. Keduanya memiliki keuntungan dan kerugian masing-masing. Kita harus bisa memilih versi yang tepat sesuai dengan kebutuhan soal.
  \item Kunci dari mengerjakan soal DP adalah mendapatkan \foreignTerm{state} dan rekurens dari solusi DP. 
  \item Banyak latihan mengerjakan soal DP dapat melatih kita untuk mendapatkan rumus DP yang sesuai.
\end{itemize}
\end{frame}

\end{document}
