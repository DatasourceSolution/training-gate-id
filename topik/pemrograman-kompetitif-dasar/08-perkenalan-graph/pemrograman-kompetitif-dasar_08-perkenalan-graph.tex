\input{../config.tex}

\title{Perkenalan \fGraph}
\author{Tim Olimpiade Komputer Indonesia}
\date{}

\usepackage{verbatim}
\usepackage{multicol}
\lstset{escapeinside={<@}{@>},belowskip=\baselineskip}
\definecolor{mygreen}{rgb}{0, 0.597, 0.199}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Pendahuluan}
Melalui dokumen ini, kalian akan:
\begin{itemize}
  \item Mengenal konsep dan terminologi \fgraph.
  \item Mengetahui jenis-jenis \fgraph.
  \item Mengenal representasi \fgraph pada pemrograman.
  \item Mengenal metode-metode yang digunakan dalam \fgraph.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi}
\begin{itemize}
  \item Diberikan sebuah struktur kota dan jalan.
  \item Terdapat $V$ kota, dan $E$ ruas jalan.
  \item Setiap ruas jalan menghubungkan dua kota.
  \item Diberikan kota awal, tentukan berapa banyak ruas jalan paling sedikit yang perlu dilalui untuk mencapai suatu kota tujuan!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pertanyaan}
\begin{center}
  \large Bagaimana cara merepresentasikan struktur perkotaan dan jalan pada pemrograman?
\end{center}
\end{frame}

\section{Perkenalan Graph}
\frame{\sectionpage}

\begin{frame}
\frametitle{Mengenal \fGraph}
\fGraph adalah struktur yang terdiri dari \alert{\fnode/\foreignTerm{vertex}} dan \alert{\fedge.}\newline

\fNode direpresentasikan dengan bentuk lingkaran dan \fedge direpresentasikan dengan bentuk garis pada ilustrasi berikut:

\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/graph.pdf}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Mengenal \fGraph (lanj.)}
\begin{itemize}
  \item \fEdge merupakan penghubung antar \fnode.
  \item \alert{\fDegree} suatu \fnode merupakan jumlah \fedge yang terhubung pada \fnode tersebut
  \item Pada contoh ilustrasi berikut, \fdegree \fnode A = 4, \fdegree \fnode B = 3, dan \fdegree \fnode C = 5.
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/graph.pdf}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Jenis-jenis \fGraph}
Berdasarkan hubungan antar \fnode:
\begin{itemize}
  \item \foreignTerm{Undirected} \fgraph (dua arah): \fedge dari A ke B dapat ditelusuri dari A ke B dan B ke A. 
  \item \foreignTerm{Directed} \fgraph (satu arah): \fedge dari A ke B hanya dapat ditelusuri dari dari A ke B.
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/unweighted-undirected.pdf}
  \ \ \ \ \ \ % If this works, this ain't stupid
  \includegraphics[width=4 cm]{asset/unweighted-directed.pdf}
  
  \foreignTerm{Undirected} dan \foreignTerm{directed} \fgraph.
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Jenis-jenis \fGraph (lanj.)}
Berdasarkan bobot dari \fedge:
\begin{itemize}
  \item \foreignTerm{Unweighted} \fGraph, yaitu \fgraph dengan \fedge yang bobotnya seragam dan hanya bermakna terdapat hubungan antar \fnode.
  \item \foreignTerm{Weighted} \fGraph, yaitu \fgraph dengan \fedge yang dapat memiliki bobot berbeda-beda. Bobot pada \fedge ini bisa jadi berupa biaya, jarak, atau waktu yang harus ditempuh jika menggunakan \fedge tersebut.
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/unweighted-undirected.pdf}
  \ \ \ \ \ \ % If this works, this ain't stupid
  \includegraphics[width=4 cm]{asset/weighted-undirected.pdf}
  
  \foreignTerm{Unweighted} dan \foreignTerm{weighted} \fgraph.
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Jenis-jenis \fGraph (lanj.)}
Tentu saja, suatu \fgraph dapat memiliki kombinasi dari sifat-sifat tersebut.

Misalnya \foreignTerm{weighted directed graph}:
\newline
\begin{figure}
  \centering
  \includegraphics[width=5 cm]{asset/weighted-directed.pdf}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Representasi \fGraph pada Pemrograman}

\begin{itemize}
  \item Dalam pemrograman, dibutuhkan sebuah struktur agar data mengenai \fgraph dapat disimpan dan diolah.
  \item Representasi yang akan kita pelajari adalah \fadjacencymatrix, \fadjacencylist, dan \fadjacencylist.
  \item Masing-masing representasi memiliki keuntungan dan kerugiannya.
  \item Penggunaan representasi \fgraph bergantung dengan masalah yang sedang dihadapi
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency Matrix}
\begin{itemize}
  \item Kita akan menggunakan matriks dengan ukuran $N \times N$ dengan $N$ merupakan banyaknya \fnode.
  \item Pada \foreignTerm{unweighted} \fgraph:
  \begin{itemize}
    \item Jika terdapat \fedge dari A ke B, maka $matrix[A][B] = 1$. 
    \item Jika tidak ada, maka $matrix[A][B] = 0$.
  \end{itemize}
\end{itemize}

\begin{center}
\begin{multicols}{2}
  $\begin{array}{c|cccc}
      & A & B & C & D \\ \hline
    A & 0 & 1 & 1 & 1 \\
    B & 1 & 0 & 0 & 0 \\
    C & 0 & 0 & 0 & 1 \\
    D & 0 & 0 & 0 & 0
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/unweighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Adjacency Matrix}
\begin{itemize}
  \item Pada \foreignTerm{weighted} \fgraph:
  \begin{itemize}
    \item Jika terdapat \fedge dari A ke B dengan bobot w, maka $matrix[A][B] = w$. 
    \item Jika tidak ada, maka dapat ditulis $matrix[A][B] = \infty$.
  \end{itemize}
\end{itemize}

\begin{center}
\begin{multicols}{2}
  $\begin{array}{c|cccc}
      & A & B & C & D \\ \hline
    A & \infty & 3 & 2 & 5 \\
    B & 1 & \infty & \infty & \infty \\
    C & \infty & \infty & \infty & 8 \\
    D & \infty & \infty & \infty & \infty
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/weighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Adjacency Matrix}
\begin{itemize}
  \item Pada \foreignTerm{undirected} \fgraph, \fadjacencymatrix simetris terhadap diagonalnya.
  \item Representasi ini mudah diimplementasikan.
  \item Menambah atau menghapus \fedge dapat dilakukan dalam $O(1)$.
  \item Untuk memeriksa apakah dua \fnode terhubung juga dapat dilakukan dalam $O(1)$.
  \item Untuk mendapatkan daftar tetangga dari suatu \fnode, dapat dilakukan iterasi $O(V)$, dengan $V$ adalah banyaknya \fnode.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency Matrix}
\begin{itemize}
  \item Kekurangan dari representasi ini adalah boros memori.
  \item Memori yang dibutuhkan selalu $O(V^2)$, tidak dapat digunakan untuk \fgraph dengan \fnode mencapai ratusan ribu.
  \item Jika banyaknya \fedge jauh lebih sedikit dari $O(V^2)$, maka banyak memori yang terbuang.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item Merupakan salah satu alternatif representasi \fgraph.
  \item Untuk setiap \fnode, buat sebuath \flist yang berisi keterangan mengenai tetangga \fnode tersebut.
  \item Misalnya untuk \foreignTerm{unweighted} \fgraph, kita cukup menyimpan \fnode-\fnode tetangga untuk setiap \fnode.
\end{itemize}
\begin{center}
\begin{multicols}{2}
  $\begin{array}{r|l}
    A & [B, C, D] \\
    B & [A] \\
    C & [D] \\
    D & [\ ]
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/unweighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item Untuk \foreignTerm{weighted} \fgraph, kita dapat menyimpan \fnode-\fnode tetangga beserta bobotnya.
\end{itemize}
\begin{center}
\begin{multicols}{2}
  $\begin{array}{r|l}
    A & [<B,3> , <C,2>, <D,5>] \\
    B & [<A,1>] \\
    C & [<D,8>] \\
    D & [\ ]
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/weighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item Kita dapat menggunakan struktur data \foreignTerm{array of lists}.
  \item Tiap \flist berisi keterangan mengenai tetangga suatu \fnode.
  \item Ukuran dari \farray merupakan $V$, yang mana $V$ merupakan banyaknya \fnode.
  \item Dengan menggunakan \flist, banyaknya memori yang digunakan untuk setiap \fnode hanya sebatas banyak tetangganya.
  \item Secara keseluruhan jika \fgraph memiliki $E$ \fedge, maka total memori yang dibutuhkan adalah $O(E)$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item \fList yang dimaksud bisa berupa \foreignTerm{Linked List} atau \foreignTerm{Resizable Array}.
  \item Bagi pengguna C++ atau Java, struktur \flist yang dapat digunakan adalah Vector atau ArrayList.
  \item Untuk pengguna C atau Pascal, struktur \foreignTerm{Linked List} perlu dibuat terlebih dahulu.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item Kompleksitas menambah \fedge adalah $O(1)$, dan menghapus adalah $O(K)$ dengan $K$ adalah banyaknya tetangga dari \fnode yang \fedge-nya dihapus.
  \item Memeriksa apakah dua \fnode terhubung oleh \fedge juga dilakukan dalam $O(K)$.
  \item Demikian juga untuk mendapatkan daftar tetangga dari \fnode, kompleksitasnya adalah $O(K)$. Perhatikan bahwa pencarian daftar tetangga ini sudah paling efisien.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Edge List}
\begin{itemize}
  \item Sesuai namanya, kita merepresentasikan \fgraph dengan sebuah \flist.
  \item Seluruh keterangan \fedge dimasukkan kedalam \flist tersebut.
  \item Berbeda dengan \fadjacencylist yang membutuhkan \foreignTerm{array of list}, representasi ini hanya butuh sebuah \flist.
\end{itemize}
\begin{center}
\begin{multicols}{2}
  $\begin{array}{l}
    <A, B>, \\
    <A, C>, \\
    <A, D>, \\
    <B, A>, \\
    <C, D> 
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/unweighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Edge List}
\begin{itemize}
  \item Untuk \foreignTerm{weighted} \fgraph, kita juga menyimpan bobot dari setiap \fedge.
\end{itemize}
\begin{center}
\begin{multicols}{2}
  $\begin{array}{l}
    <A, B, 3>, \\
    <A, C, 2>, \\
    <A, D, 5>, \\
    <B, A, 1>, \\
    <C, D, 8> 
  \end{array}$
  \break
  \begin{figure}
    \includegraphics[width=4 cm]{asset/weighted-directed.pdf}
  \end{figure}
\end{multicols} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Edge List}
\begin{itemize}
  \item Untuk implementasinya, kita membutuhkan struktur data sebuah \flist (atau \farray).
  \item Jelas bahwa memori yang dibutuhkan adalah $O(E)$, dengan $E$ adalah banyaknya \fedge pada keseluruhan \fgraph.
  \newline
  \item Pada beberapa kasus, dilakukan pengurutan terhadap \fedgelist atau digunakan struktur data \foreignTerm{Binary Search Tree}, yang memungkinkan implementasinya lebih efisien.
  Namun untuk saat ini kita tidak mempelajari hal tersebut.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adjacency List}
\begin{itemize}
  \item Kompleksitas menambah \fedge adalah $O(1)$.
  \item Bergantung dari implementasi, kompleksitas menghapus \fedge dan memeriksa keterhubungan sepasang \fnode bisa berupa $O(\log{E})$ sampai $O(E)$.
  \item Demikian juga untuk mendapatkan daftar tetangga dari \fnode, kompleksitasnya bisa berkisar antara $O(\log{E} + K)$ sampai $O(E)$, dengan $K$ adalah banyaknya tetangga dari \fnode tersebut.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Keuntungan dan Kerugian Representasi \fGraph}
Untuk \fgraph dengan $V$ \fnode dan $E$ \fedge: 
{\fontsize{9}{10}\selectfont\renewcommand{\arraystretch}{1.75}
\begin{center}
 \begin{tabular}{||r|c c c||} 
 \hline
 & \foreignTerm{Adj.Matrix} & \foreignTerm{Adj.List} & \foreignTerm{Edge List}\\
 \hline\hline
 Tambah \fedge & $O(1)$ & $O(1)$ & $O(1)$ \\ \hline
 Hapus \fedge & $O(1)$ & $O(K)$ & $O(E)$ \\ \hline
 Cek keterhubungan & $O(1)$ & $O(K)$ & $O(E)$ \\ \hline
 Daftar tetangga & $O(V)$ & $O(K)$ & $O(E)$ \\ \hline
 Kebutuhan memori & $O(V^2)$ & $O(E)$ & $O(E)$ \\ [0.5ex] 
 \hline
\end{tabular}
\end{center}
}
Dengan $K$ adalah banyaknya \fnode yang bertetangga dengan \fnode yang sedang kita periksa.
\end{frame}

%\begin{frame}[fragile]
%\frametitle{Pseudocode Representasi \fGraph}
%
%Adjacency Matrix
%\begin{lstlisting}
%  integer AdjMatrix[N][N]
%  set AdjMatrix = 0
%  
%  <@\textcolor{mygreen}{//edge dari 1 ke 4 pada undirected unweighted graph}@>
%  AdjMatrix[1][4] = 1
%  AdjMatrix[4][1] = 1
%\end{lstlisting}
%Adjacency List
%\begin{lstlisting}
%  List<integer> AdjList[N]
%  
%  <@\textcolor{mygreen}{//edge dari 1 ke 4 pada undirected unweighted graph}@>
%  AdjList[1].push(4)
%  AdjList[4].push(1)
%  
%\end{lstlisting}
%\end{frame}
%
%\begin{frame}[fragile]
%\frametitle{Pseudocode Representasi \fGraph (lanj.)}
%
%Edge List
%\begin{lstlisting}
%  List<{integer,integer}> EdgeList
%  
%  <@\textcolor{mygreen}{//edge dari 1 ke 4 pada undirected unweighted graph}@>
%  EdgeList.push({1,4})
%  
%  List<{integer,integer,integer}> WeightedList
%  
%  <@\textcolor{mygreen}{//edge dari 2 ke 3 dengan bobot 5 pada undirected graph}@>
%  WeightedList.push({2,3,5})
%\end{lstlisting}
%\end{frame}

\begin{comment}
\begin{frame}
\frametitle{Keuntungan dan Kerugian Representasi \fGraph}

\begin{itemize}
  \item Adjacency Matrix memakan lebih banyak memori. Hal ini dikarenakan adjacency matrix menyimpan keterangan dari satu node ke semua node. Sedangkan dalam adjacency list, suatu node hanya menyimpan keterangan mengenai node lain yang memiliki edge. Oleh karena itu, adjacency list lebih baik digunakan ketika edge yang terdapat tidak teralu banyak.
  \item Untuk melakukan pengecekan atau perubahan edge dari A ke B, pada adjacency matrix dapat dilakukan dengan hanya melihat dan mengubah matrix[A][B]. Sedangkan pada adjacency list, kita harus mengiterasi seluruh elemen pada list[A]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Keuntungan dan Kerugian Representasi \fGraph (lanj.)}
\begin{itemize}
  \item Jika ada edge dari A ke B yang akan dibuang, maka pada adjacency matrix kita hanya perlu mengubah nilai Matrix[A][B]. Sedangkan pada adjacency list, harus dilakukan iterasi terlebih dahulu untuk mencari edge tersebut, lalu menghapusnya juga lebih rumit karena harus menggeser seluruh elemen setelahnya.
  \item Untuk mencari tetangga-tetangganya, maka pada adjacency matrix perlu dilakukan iterasi terhadap seluruh node yagn ada. Sementara itu, pada adjacency list hanya perlu dilakukan iterasi pada list yang isinya merupakan tetangga dari node yang bersangkutan.
\end{itemize}
\end{frame}
\end{comment}

\section{Graph Traversal}
\frame{\sectionpage}

\begin{frame}
\frametitle{\fGraph Traversal}

\begin{itemize}
  \item Representasi \fGraph saja belum berguna karena belum dapat mencari informasi mengenai suatu \fgraph
  \item \alert{\fGraph Traversal} merupakan penelusuran \fnode-\fnode pada suatu \fgraph.
  \item Contoh permasalahannya adalah diberikan node A dan node B, ditanya apakah dari node A bisa pergi ke node B menggunakan edge yang ada?
  \item Permasalahan tersebut dapat diselesaikan menggunakan \fgraph traversal.
  \item Terdapat 2 metode yang dapat digunakan, yaitu DFS dan BFS.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\fGraph Traversal}
\begin{itemize}
  \item Representasi \fGraph saja belum berguna karena belum dapat mencari informasi mengenai suatu \fgraph
  \item \alert{\fGraph Traversal} merupakan penelusuran \fnode-\fnode pada suatu \fgraph.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\fGraph Traversal}
\begin{itemize}
  \item Diberikan \fnode A dan \fnode B, apakah dari \fnode A kita dapat pergi ke \fnode B dengan \fedge yang ada?
  \item Permasalahan tersebut dapat diselesaikan menggunakan \fgraphtraversal.
  \newline
  \item Terdapat 2 metode yang dapat digunakan, yaitu \newTerm{DFS} dan \newTerm{BFS}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{DFS: Depth-First Search}
Penelusuran dilakukan terhadap \fnode yang lebih dalam terlebih dahulu (\foreignTerm{depth-first}). 

Sebagai contoh, misal terdapat \fgraph berikut:

\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/plain.pdf}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{DFS: Depth-First Search}
Penelusuran secara DFS akan dilakukan dengan cara berikut:
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/dfs.pdf}
\end{figure}
\begin{itemize}
  \item Angka pada \fnode menunjukkan urutan \fnode tersebut dikunjungi.
  \item \fNode 1 dikunjungi pertama, \fnode 2 dikunjungi kedua, dan seterusnya).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{DFS (lanj.)}
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/dfs.pdf}
\end{figure}
\begin{itemize}
  \item Dapat dilihat bahwa DFS mencoba menelusuri \fnode yang dalam terlebih dahulu.
  \item \fNode yang dekat dengan \fnode pertama (seperti \fnode 7 dan 8) akan dikunjungi setelah DFS selesai mengunjungi \fnode yang lebih dalam (seperti \fnode 3, 4, dan 5)
  \item Dalam pemrograman, DFS biasa dilakukan dengan rekursi atau struktur data \foreignTerm{stack}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Implementasi DFS}
%\begin{lstlisting}
%integer AdjMatrix[N][N]
%boolean flag[N]
%set flag = false
%flag[1] = true
%
%procedure DFS(integer currNode):
%  for i=1 to N
%    <@\textcolor{mygreen}{//check apakah ada edge dan belum pernah dikunjungi}@>
%    if AdjMatrix[currNode][i]==1 and flag[i]==false
%      flag[i] = true
%      DFS(i)
%end        
%\end{lstlisting}
Asumsikan:
\begin{itemize}
  \item Setiap \fnode dinomori dari 1 sampai $V$
  \item $adj(x)$ menyatakan himpunan tetangga dari \fnode $x$.
  \item $visit[x]$ bernilai $true$ hanya jika $x$ telah dikunjungi.
\end{itemize}
\begin{codebox}
  \Procname{$\proc{DFS}(currNode)$}
  \li \textbf{Print} "mengunjungi $currNode$"
  \li \For \textbf{each} $adjNode \in adj(currNode)$ \Do
  \li   \If \textbf{not} $visit[adjNode]$ \Then
  \li     $visit[adjNode] \gets true$
  \li     $\proc{DFS}(adjNode)$
        \End
      \End
\end{codebox}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementasi DFS (lanj.)}
Berikut contoh implementasi DFS menggunakan \foreignTerm{stack}.
%\begin{lstlisting}
%integer AdjMatrix[N][N]
%boolean flag[N]
%set flag = false
%stack <integer> s
%
%s.push(1), flag[1] = true
%while s is not empty
%  integer currNode = s.top()
%  s.pop()
%  for i=1 to N
%    if AdjMatrix[currNode][i]==1 and flag[i]==false
%      flag[i] = true
%      s.push(i)
%        
%\end{lstlisting}
\begin{codebox}
  \Procname{$\proc{DFS}()$}
  \li \Comment Inisialisasi $stack$ sebagai stack kosong.
  \li $stack.push(initialNode)$
  \li $visit[initialNode] \gets true$
  \li \While \textbf{not} $stack.empty()$ \Do
  \li   $currNode \gets stack.top()$
  \li   $stack.pop()$
  \li   \textbf{Print} "mengunjungi $currNode$"
  \li   \For \textbf{each} $adjNode \in adj(currNode)$ \Do
  \li     \If \textbf{not} $visit[adjNode]$ \Then
  \li       $visit[adjNode] \gets true$
  \li       $stack.push(adjNode)$
          \End
        \End
      \End
\end{codebox}
\end{frame}

\begin{frame}
\frametitle{BFS: Breadth-First Search}
Penelusuran \fnode pada \fgraph dilakukan lapis demi lapis. 

Semakin dekat suatu \fnode dengan \fnode awal, \fnode tersebut akan dikunjungi terlebih dahulu. 

\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/bfs.pdf}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{BFS (lanj.)}
\begin{figure}
  \centering
  \includegraphics[width=4 cm]{asset/bfs.pdf}
\end{figure}
\begin{itemize}
  \item Angka pada gambar menunjukkan urutan \fnode tersebut dikunjungi.
  \item Dalam pemrograman, BFS biasa diimplementasikan dengan bantuan struktur data \foreignTerm{queue}.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementasi BFS}
%BFS membutuhkan bantuan struktur data queue. Berikut adalah potongan kodenya\newline
%\begin{lstlisting}
%integer AdjMatrix[N][N]
%boolean flag[N]
%set flag = false
%queue <integer> q
%
%q.push(1), flag[1] = true
%while q is not empty
%  integer currNode = q.front()
%  q.pop()
%  for i=1 to N
%    if AdjMatrix[currNode][i]==1 and flag[i]==false
%      flag[i] = true
%      q.push(i)
%        
%\end{lstlisting}
\begin{codebox}
  \Procname{$\proc{BFS}()$}
  \li \Comment Inisialisasi $queue$ sebagai queue kosong.
  \li $queue.push(initialNode)$
  \li $visit[initialNode] \gets true$
  \li \While \textbf{not} $queue.empty()$ \Do
  \li   $currNode \gets queue.front()$
  \li   $queue.pop()$
  \li   \textbf{Print} "mengunjungi $currNode$"
  \li   \For \textbf{each} $adjNode \in adj(currNode)$ \Do
  \li     \If \textbf{not} $visit[adjNode]$ \Then
  \li       $visit[adjNode] \gets true$
  \li       $queue.push(adjNode)$
          \End
        \End
      \End
\end{codebox}
\end{frame}

\begin{frame}
\frametitle{Contoh Permasalahan}
\begin{itemize}
  \item Baik DFS maupun BFS sama-sama mengunjungi setiap \fnode tepat satu kali, dengan memanfaatkan seluruh \fedge.
  \item Kompleksitas dari kedua metode adalah $O(V + E)$.
  \item Penggunaan DFS atau BFS dapat disesuaikan dengan persoalan yang dihadapi.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Contoh Permasalahan}
Pak Dengklek tinggal di kota A. Suatu hari, beliau ingin pergi ke kota B. Terdapat beberapa jalan yang menghubungkan kota-kota dalam negara tempat beliau tinggal. Namun, karena beliau sudah tua, Pak Dengklek ingin melewati jalan seminimal mungkin untuk sampai ke kota B.
\newline\newline
Diberikan keterangan mengenai kota A, kota B, dan jalan-jalan yang terdapat dalam negara Pak Dengklek, outputkan berapa jalan minimal yang beliau harus lewati untuk pergi dari kota A ke kota B!
\end{frame}

\begin{frame}
\frametitle{Pembahasan Permasalahan}
Permasalahan di atas dapat diselesaikan menggunakan BFS. Karena sifat BFS yang menelusuri node per layer, maka dapat disimpulkan bahwa jika suatu node terkunjungi, maka pasti jarak yang ditempuh merupakan jarak terpendek dari node awal. Hal ini berlaku pada unweighted \fgraph yang edgenya tidak memiliki bobot.
\newline\newline
Dengan demikian, permasalahan di atas dapat diselesaikan dengan menggunakan BFS. Pada slide selanjutnya akan diberikan contoh implementasi untuk menyelesaikan permasalahan jarak terpendek tersebut!
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementasi Permasalahan}

\begin{lstlisting}
integer AdjMatrix[N][N] , A , B , jarak = -1
queue < (integer,integer) > q
<@\textcolor{mygreen}{//Queue menyimpan node yang dikunjungi dan jarak dari A}@>
q.push({A,0}), flag[A] = true
while q is not empty
  (integer,integer) currNode = q.front()
  q.pop()
  <@\textcolor{mygreen}{//Cek jika telah sampai di kota B}@>
  if currNode.first == B
    jarak = currNode.second, break
  for i=1 to N
    if AdjMatrix[currNode.first][i]==1 and flag[i]==false
      flag[i] = true
      q.push({i,currNode.second+1})
if jarak!=-1
  print jarak
else
  print 'Tidak dapat ke kota B'    
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Tree}
\begin{itemize}
  \item \foreignTerm{Tree} merupakan bentuk khusus dari \fgraph
  \item Seluruh node pada tree terhubung (tidak ada node yang tidak dapat dikunjungi dari node lain) dan tidak terdapat \alert{cycle}
  \item Jumlah edge dalam sebuah tree pasti berjumlah sebanyak (Node - 1)
\end{itemize}

\includegraphics[width=3.5 cm]{asset/not-tree.pdf}
\hspace{\fill}
\includegraphics[width=4 cm]{asset/tree.pdf}
\newline\newline
Pada gambar di atas, gambar kiri bukan sebuah tree karena memiliki cycle, sedangkan gambar kanan merupakan tree. 
\end{frame}

\begin{frame}
\frametitle{Directed Acyclic \fGraph}
\begin{itemize}
  \item \foreignTerm{Directed Acyclic \fGraph (DAG)} merupakan bentuk khusus dari directed \fgraph.
  \item DAG tidak memiliki \alert{direct cycle}
  \item Berbeda dengan tree yang mana setiap nodenya harus dapat dicapai node lainnya, sifat tersebut tidak berlaku pada DAG
\end{itemize}

\includegraphics[width=4 cm]{asset/dag.pdf}
\hspace{\fill}
\includegraphics[width=5 cm]{asset/not-dag.pdf}
\newline\newline
Pada gambar di atas, gambar kiri merupakan DAG, sedangkan gambar kanan bukan DAG karena memiliki cycle
\end{frame}

\end{document}
